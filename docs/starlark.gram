# PEG grammar for starlark

file[mod_ty]: a=[statements] ENDMARKER
interactive[mod_ty]: a=statement_newline
eval[mod_ty]: a=expressions NEWLINE* ENDMARKER
func_type[mod_ty]: '(' a=[type_expressions] ')' '->' b=expression NEWLINE* ENDMARKER { FunctionType(a, b, p->arena) }
fstring: star_expressions

# type_expressions allow */** but ignore them
type_expressions:
    | a=','.expression+ ',' '*' b=expression ',' '**' c=expression {
        (asdl_expr_seq*)_PyPegen_seq_append_to_end(
            p,
            CHECK(asdl_seq*, _PyPegen_seq_append_to_end(p, a, b)),
            c) }
    | a=','.expression+ ',' '*' b=expression { (asdl_expr_seq*)_PyPegen_seq_append_to_end(p, a, b) }
    | a=','.expression+ ',' '**' b=expression { (asdl_expr_seq*)_PyPegen_seq_append_to_end(p, a, b) }
    | '*' a=expression ',' '**' b=expression {
        (asdl_expr_seq*)_PyPegen_seq_append_to_end(
            p,
            CHECK(asdl_seq*, _PyPegen_singleton_seq(p, a)),
            b) }
    | '*' a=expression { (asdl_expr_seq*)_PyPegen_singleton_seq(p, a) }
    | '**' a=expression { (asdl_expr_seq*)_PyPegen_singleton_seq(p, a) }
    | a=','.expression+ {a}

statements[asdl_stmt_seq*]: a=statement+ { (asdl_stmt_seq*)_PyPegen_seq_flatten(p, a) }
statement[asdl_stmt_seq*]: a=compound_stmt { (asdl_stmt_seq*)_PyPegen_singleton_seq(p, a) } | a[asdl_stmt_seq*]=simple_stmts { a }
statement_newline[asdl_stmt_seq*]:
    | a=compound_stmt NEWLINE
    | simple_stmts
    | NEWLINE
    | ENDMARKER
simple_stmts[asdl_stmt_seq*]:
    | a=simple_stmt !';' NEWLINE { (asdl_stmt_seq*)_PyPegen_singleton_seq(p, a) } # Not needed, there for speedup
    | a[asdl_stmt_seq*]=';'.simple_stmt+ [';'] NEWLINE { a }
# NOTE: assignment MUST precede expression, else parsing a simple assignment
# will throw a SyntaxError.
simple_stmt:
    | assignment
    | e=star_expressions { _Py_Expr(e, EXTRA) }
    | &'return' return_stmt
    | 'pass' { _Py_Pass(EXTRA) }
    | &'del' del_stmt
    | 'break' { _Py_Break(EXTRA) }
    | 'continue' { _Py_Continue(EXTRA) }
compound_stmt:
    | &('def' | '@') function_def
    | &'if' if_stmt
    | &('for') for_stmt
    | &'try' try_stmt
    | &'while' while_stmt

assignment:
    | a=NAME ':' b=expression c=['=' d=annotated_rhs { d }]
    | a=('(' b=single_target ')'
         | single_subscript_attribute_target) ':' b=expression c=['=' d=annotated_rhs { d }]
    | a=(z=star_targets '=' { z })+ b=(star_expressions) !'=' tc=[TYPE_COMMENT]
    | a=single_target b=augassign ~ c=(star_expressions)
    | invalid_assignment

augassign[AugOperator*]:
    | '+=' { _PyPegen_augoperator(p, Add) }
    | '-=' { _PyPegen_augoperator(p, Sub) }
    | '*=' { _PyPegen_augoperator(p, Mult) }
    | '@=' { CHECK_VERSION(AugOperator*, 5, "The '@' operator is", _PyPegen_augoperator(p, MatMult)) }
    | '/=' { _PyPegen_augoperator(p, Div) }
    | '%=' { _PyPegen_augoperator(p, Mod) }
    | '&=' { _PyPegen_augoperator(p, BitAnd) }
    | '|=' { _PyPegen_augoperator(p, BitOr) }
    | '^=' { _PyPegen_augoperator(p, BitXor) }
    | '<<=' { _PyPegen_augoperator(p, LShift) }
    | '>>=' { _PyPegen_augoperator(p, RShift) }
    | '**=' { _PyPegen_augoperator(p, Pow) }
    | '//=' { _PyPegen_augoperator(p, FloorDiv) }


del_stmt:
    | 'del' a=del_targets &(';' | NEWLINE)
    | invalid_del_stmt

if_stmt:
    | 'if' a=expression ':' b=block c=elif_stmt
    | 'if' a=expression ':' b=block c=[else_block]
elif_stmt:
    | 'elif' a=expression ':' b=block c=elif_stmt
    | 'elif' a=expression ':' b=block c=[else_block]
else_block[asdl_stmt_seq*]: 'else' ':' b=block { b }

while_stmt:
    | 'while' a=expression ':' b=block c=[else_block] { _Py_While(a, b, c, EXTRA) }

for_stmt:
    | 'for' t=star_targets 'in' ~ ex=star_expressions ':' tc=[TYPE_COMMENT] b=block el=[else_block]
    | invalid_for_target


return_stmt:
    | 'return' a=[star_expressions] { _Py_Return(a, EXTRA) }

function_def:
    | 'def' n=NAME '(' params=[params] ')' a=['->' z=expression { z }] ':' tc=[func_type_comment] b=block
func_type_comment[Token*]:
    | NEWLINE t=TYPE_COMMENT &(NEWLINE INDENT) { t }  # Must be followed by indented block
    | invalid_double_type_comments
    | TYPE_COMMENT

params[arguments_ty]:
    | invalid_parameters
    | parameters

parameters[arguments_ty]:
    | a=slash_no_default b[asdl_arg_seq*]=param_no_default* c=param_with_default* d=[star_etc]
    | a=slash_with_default b=param_with_default* c=[star_etc]
    | a[asdl_arg_seq*]=param_no_default+ b=param_with_default* c=[star_etc]
    | a=param_with_default+ b=[star_etc]
    | a=star_etc

# Some duplication here because we can't write (',' | &')'),
# which is because we don't support empty alternatives (yet).
#
slash_no_default[asdl_arg_seq*]:
    | a[asdl_arg_seq*]=param_no_default+ '/' ',' { a }
    | a[asdl_arg_seq*]=param_no_default+ '/' &')' { a }
slash_with_default[SlashWithDefault*]:
    | a=param_no_default* b=param_with_default+ '/' ','
    | a=param_no_default* b=param_with_default+ '/' &')'

star_etc[StarEtc*]:
    | '*' a=param_no_default b=param_maybe_default* c=[kwds]
    | '*' ',' b=param_maybe_default+ c=[kwds]
    | a=kwds
    | invalid_star_etc

kwds[arg_ty]: '**' a=param_no_default { a }

# One parameter.  This *includes* a following comma and type comment.
#
# There are three styles:
# - No default
# - With default
# - Maybe with default
#
# There are two alternative forms of each, to deal with type comments:
# - Ends in a comma followed by an optional type comment
# - No comma, optional type comment, must be followed by close paren
# The latter form is for a final parameter without trailing comma.
#
param_no_default[arg_ty]:
    | a=param ','
    | a=param &')'
param_with_default[NameDefaultPair*]:
    | a=param c=default ','
    | a=param c=default &')'
param_maybe_default[NameDefaultPair*]:
    | a=param c=default? ','
    | a=param c=default? &')'
param[arg_ty]: a=NAME

default: '=' a=expression


block[asdl_stmt_seq*]:
    | NEWLINE INDENT a=statements DEDENT { a }
    | simple_stmts
    | invalid_block

star_expressions:
    | a=star_expression b=(',' c=star_expression { c })+ [',']
    | a=star_expression ','
    | star_expression
star_expression:
    | '*' a=bitwise_or { _Py_Starred(a, Load, EXTRA) }
    | expression

star_expressions: a=','.star_expression+ [','] { a }
star_expression:
    | '*' a=bitwise_or { _Py_Starred(a, Load, EXTRA) }
    | expression

annotated_rhs: star_expressions

expressions:
    | a=expression b=(',' c=expression { c })+ [',']
    | a=expression ','
    | expression
expression:
    | a=disjunction 'if' b=disjunction 'else' c=expression { _Py_IfExp(b, a, c, EXTRA) }
    | disjunction
    | lambdef

lambdef:
    | 'lambda' a=[lambda_params] ':' b=expression

lambda_params[arguments_ty]:
    | invalid_lambda_parameters
    | lambda_parameters

# lambda_parameters etc. duplicates parameters but without annotations
# or type comments, and if there's no comma after a parameter, we expect
# a colon, not a close parenthesis.  (For more, see parameters above.)
#
lambda_parameters[arguments_ty]:
    | a=lambda_slash_no_default b[asdl_arg_seq*]=lambda_param_no_default* c=lambda_param_with_default* d=[lambda_star_etc]
    | a=lambda_slash_with_default b=lambda_param_with_default* c=[lambda_star_etc]
    | a[asdl_arg_seq*]=lambda_param_no_default+ b=lambda_param_with_default* c=[lambda_star_etc]
    | a=lambda_param_with_default+ b=[lambda_star_etc]
    | a=lambda_star_etc

lambda_slash_no_default[asdl_arg_seq*]:
    | a[asdl_arg_seq*]=lambda_param_no_default+ '/' ',' { a }
    | a[asdl_arg_seq*]=lambda_param_no_default+ '/' &':' { a }
lambda_slash_with_default[SlashWithDefault*]:
    | a=lambda_param_no_default* b=lambda_param_with_default+ '/' ','
    | a=lambda_param_no_default* b=lambda_param_with_default+ '/' &':'

lambda_star_etc[StarEtc*]:
    | '*' a=lambda_param_no_default b=lambda_param_maybe_default* c=[lambda_kwds]
    | '*' ',' b=lambda_param_maybe_default+ c=[lambda_kwds]
    | a=lambda_kwds { _PyPegen_star_etc(p, NULL, NULL, a) }
    | invalid_lambda_star_etc

lambda_kwds[arg_ty]: '**' a=lambda_param_no_default { a }

lambda_param_no_default[arg_ty]:
    | a=lambda_param ',' { a }
    | a=lambda_param &':' { a }
lambda_param_with_default[NameDefaultPair*]:
    | a=lambda_param c=default ','
    | a=lambda_param c=default &':'
lambda_param_maybe_default[NameDefaultPair*]:
    | a=lambda_param c=default? ','
    | a=lambda_param c=default? &':'
lambda_param[arg_ty]: a=NAME

disjunction:
    | a=conjunction b=('or' c=conjunction { c })+
    | conjunction
conjunction:
    | a=inversion b=('and' c=inversion { c })+
    | inversion
inversion:
    | 'not' a=inversion
    | comparison
comparison:
    | a=bitwise_or b=compare_op_bitwise_or_pair+
    | bitwise_or
compare_op_bitwise_or_pair[CmpopExprPair*]:
    | eq_bitwise_or
    | noteq_bitwise_or
    | lte_bitwise_or
    | lt_bitwise_or
    | gte_bitwise_or
    | gt_bitwise_or
    | notin_bitwise_or
    | in_bitwise_or
    | isnot_bitwise_or
    | is_bitwise_or
eq_bitwise_or[CmpopExprPair*]: '==' a=bitwise_or
noteq_bitwise_or[CmpopExprPair*]:
    | (tok='!=' { _PyPegen_check_barry_as_flufl(p, tok) ? NULL : tok}) a=bitwise_or
lte_bitwise_or[CmpopExprPair*]: '<=' a=bitwise_or
lt_bitwise_or[CmpopExprPair*]: '<' a=bitwise_or
gte_bitwise_or[CmpopExprPair*]: '>=' a=bitwise_or
gt_bitwise_or[CmpopExprPair*]: '>' a=bitwise_or
notin_bitwise_or[CmpopExprPair*]: 'not' 'in' a=bitwise_or
in_bitwise_or[CmpopExprPair*]: 'in' a=bitwise_or
isnot_bitwise_or[CmpopExprPair*]: 'is' 'not' a=bitwise_or
is_bitwise_or[CmpopExprPair*]: 'is' a=bitwise_or

bitwise_or:
    | a=bitwise_or '|' b=bitwise_xor { _Py_BinOp(a, BitOr, b, EXTRA) }
    | bitwise_xor
bitwise_xor:
    | a=bitwise_xor '^' b=bitwise_and { _Py_BinOp(a, BitXor, b, EXTRA) }
    | bitwise_and
bitwise_and:
    | a=bitwise_and '&' b=shift_expr { _Py_BinOp(a, BitAnd, b, EXTRA) }
    | shift_expr
shift_expr:
    | a=shift_expr '<<' b=sum { _Py_BinOp(a, LShift, b, EXTRA) }
    | a=shift_expr '>>' b=sum { _Py_BinOp(a, RShift, b, EXTRA) }
    | sum

sum:
    | a=sum '+' b=term { _Py_BinOp(a, Add, b, EXTRA) }
    | a=sum '-' b=term { _Py_BinOp(a, Sub, b, EXTRA) }
    | term
term:
    | a=term '*' b=factor { _Py_BinOp(a, Mult, b, EXTRA) }
    | a=term '/' b=factor { _Py_BinOp(a, Div, b, EXTRA) }
    | a=term '//' b=factor { _Py_BinOp(a, FloorDiv, b, EXTRA) }
    | a=term '%' b=factor { _Py_BinOp(a, Mod, b, EXTRA) }
    | a=term '@' b=factor { CHECK_VERSION(expr_ty, 5, "The '@' operator is", _Py_BinOp(a, MatMult, b, EXTRA)) }
    | factor
factor:
    | '+' a=factor { _Py_UnaryOp(UAdd, a, EXTRA) }
    | '-' a=factor { _Py_UnaryOp(USub, a, EXTRA) }
    | '~' a=factor { _Py_UnaryOp(Invert, a, EXTRA) }
    | power
power:
    | a=await_primary '**' b=factor { _Py_BinOp(a, Pow, b, EXTRA) }
    | await_primary
await_primary:
    | AWAIT a=primary { CHECK_VERSION(expr_ty, 5, "Await expressions are", _Py_Await(a, EXTRA)) }
    | primary
primary:
    | invalid_primary  # must be before 'primay genexp' because of invalid_genexp
    | a=primary '.' b=NAME { _Py_Attribute(a, b->v.Name.id, Load, EXTRA) }
    | a=primary b=genexp { _Py_Call(a, CHECK(asdl_expr_seq*, (asdl_expr_seq*)_PyPegen_singleton_seq(p, b)), NULL, EXTRA) }
    | a=primary '(' b=[arguments] ')'
    | a=primary '[' b=slices ']' { _Py_Subscript(a, b, Load, EXTRA) }
    | atom

slices:
    | a=slice !',' { a }
    | a=','.slice+ [','] { _Py_Tuple(a, Load, EXTRA) }
slice:
    | a=[expression] ':' b=[expression] c=[':' d=[expression] { d }] { _Py_Slice(a, b, c, EXTRA) }
    | a=expression { a }
atom:
    | NAME
    | 'True'
    | 'False'
    | 'None'
    | &STRING strings
    | NUMBER
    | &'(' (tuple | group | genexp)
    | &'[' (list | listcomp)
    | &'{' (dict | dictcomp)
    | '...'

strings: a=STRING+
list:
    | '[' a=[star_expressions] ']'
listcomp:
    | '[' a=expression ~ b=for_if_clauses ']'
    | invalid_comprehension
tuple:
    | '(' a=[y=star_expression ',' z=[star_expressions] ] ')'
group:
    | '(' a=(expression) ')' { a }
    | invalid_group
genexp:
    | '(' a=expression ~ b=for_if_clauses ')'
    | invalid_comprehension
dict:
    | '{' a=[double_starred_kvpairs] '}'
dictcomp:
    | '{' a=kvpair b=for_if_clauses '}'
    | invalid_dict_comprehension
double_starred_kvpairs[asdl_seq*]: a=','.double_starred_kvpair+ [','] { a }
double_starred_kvpair[KeyValuePair*]:
    | '**' a=bitwise_or { _PyPegen_key_value_pair(p, NULL, a) }
    | kvpair
kvpair[KeyValuePair*]: a=expression ':' b=expression { _PyPegen_key_value_pair(p, a, b) }
for_if_clauses[asdl_comprehension_seq*]:
    | a[asdl_comprehension_seq*]=for_if_clause+ { a }
for_if_clause[comprehension_ty]:
    | 'for' a=star_targets 'in' ~ b=disjunction c=('if' z=disjunction { z })*
    | invalid_for_target

arguments:
    | a=args [','] &')' { a }
    | invalid_arguments
args:
    | a=','.(starred_expression | expression !'=')+ b=[',' k=kwargs {k}] { _PyPegen_collect_call_seqs(p, a, b, EXTRA) }
    | a=kwargs
kwargs[asdl_seq*]:
    | a=','.kwarg_or_starred+ ',' b=','.kwarg_or_double_starred+ { _PyPegen_join_sequences(p, a, b) }
    | ','.kwarg_or_starred+
    | ','.kwarg_or_double_starred+
starred_expression:
    | '*' a=expression { _Py_Starred(a, Load, EXTRA) }
kwarg_or_starred[KeywordOrStarred*]:
    | a=NAME '=' b=expression {
        _PyPegen_keyword_or_starred(p, CHECK(keyword_ty, _Py_keyword(a->v.Name.id, b, EXTRA)), 1) }
    | a=starred_expression { _PyPegen_keyword_or_starred(p, a, 0) }
    | invalid_kwarg
kwarg_or_double_starred[KeywordOrStarred*]:
    | a=NAME '=' b=expression {
        _PyPegen_keyword_or_starred(p, CHECK(keyword_ty, _Py_keyword(a->v.Name.id, b, EXTRA)), 1) }
    | '**' a=expression { _PyPegen_keyword_or_starred(p, CHECK(keyword_ty, _Py_keyword(NULL, a, EXTRA)), 1) }
    | invalid_kwarg

# NOTE: star_targets may contain *bitwise_or, targets may not.
star_targets:
    | a=star_target !',' { a }
    | a=star_target b=(',' c=star_target { c })* [','] {
        _Py_Tuple(CHECK(asdl_expr_seq*, _PyPegen_seq_insert_in_front(p, a, b)), Store, EXTRA) }
star_targets_seq: a=','.star_target+ [','] { a }
star_target:
    | '*' a=(!'*' star_target)
    | a=t_primary '.' b=NAME !t_lookahead { _Py_Attribute(a, b->v.Name.id, Store, EXTRA) }
    | a=t_primary '[' b=slices ']' !t_lookahead { _Py_Subscript(a, b, Store, EXTRA) }
    | star_atom
star_atom:
    | a=NAME { _PyPegen_set_expr_context(p, a, Store) }
    | '(' a=star_target ')' { _PyPegen_set_expr_context(p, a, Store) }
    | '(' a=[star_targets_seq] ')' { _Py_Tuple(a, Store, EXTRA) }
    | '[' a=[star_targets_seq] ']' { _Py_List(a, Store, EXTRA) }

single_target:
    | single_subscript_attribute_target
    | a=NAME { _PyPegen_set_expr_context(p, a, Store) }
    | '(' a=single_target ')' { a }
single_subscript_attribute_target:
    | a=t_primary '.' b=NAME !t_lookahead { _Py_Attribute(a, b->v.Name.id, Store, EXTRA) }
    | a=t_primary '[' b=slices ']' !t_lookahead { _Py_Subscript(a, b, Store, EXTRA) }

del_targets: a=','.del_target+ [','] { a }
del_target:
    | a=t_primary '.' b=NAME !t_lookahead { _Py_Attribute(a, b->v.Name.id, Del, EXTRA) }
    | a=t_primary '[' b=slices ']' !t_lookahead { _Py_Subscript(a, b, Del, EXTRA) }
    | del_t_atom
del_t_atom:
    | a=NAME { _PyPegen_set_expr_context(p, a, Del) }
    | '(' a=del_target ')' { _PyPegen_set_expr_context(p, a, Del) }
    | '(' a=[del_targets] ')' { _Py_Tuple(a, Del, EXTRA) }
    | '[' a=[del_targets] ']' { _Py_List(a, Del, EXTRA) }

targets: a=','.target+ [','] { a }
target:
    | a=t_primary '.' b=NAME !t_lookahead { _Py_Attribute(a, b->v.Name.id, Store, EXTRA) }
    | a=t_primary '[' b=slices ']' !t_lookahead { _Py_Subscript(a, b, Store, EXTRA) }
    | t_atom
t_primary:
    | a=t_primary '.' b=NAME &t_lookahead { _Py_Attribute(a, b->v.Name.id, Load, EXTRA) }
    | a=t_primary '[' b=slices ']' &t_lookahead { _Py_Subscript(a, b, Load, EXTRA) }
    | a=t_primary b=genexp &t_lookahead {
        _Py_Call(a, CHECK(asdl_expr_seq*, (asdl_expr_seq*)_PyPegen_singleton_seq(p, b)), NULL, EXTRA) }
    | a=t_primary '(' b=[arguments] ')' &t_lookahead
    | a=atom &t_lookahead { a }
t_lookahead: '(' | '[' | '.'
t_atom:
    | a=NAME
    | '(' a=target ')'
    | '(' b=[targets] ')'
    | '[' b=[targets] ']'


# From here on, there are rules for invalid syntax with specialised error messages
invalid_arguments:
    | args ',' '*'
    | a=expression for_if_clauses ',' [args | expression for_if_clauses]
    | a=args for_if_clauses { _PyPegen_nonparen_genexp_in_call(p, a) }
    | args ',' a=expression for_if_clauses
    | a=args ',' args { _PyPegen_arguments_parsing_error(p, a) }
invalid_kwarg:
    | a=expression '='
invalid_assignment:
    | a=invalid_ann_assign_target ':' expression
    | a=star_expression ',' star_expressions* ':' expression
    | a=expression ':' expression
    | (star_targets '=')* a=star_expressions '='
    | a=star_expressions augassign (star_expressions)
invalid_ann_assign_target:
    | list
    | tuple
    | '(' a=invalid_ann_assign_target ')' { a }
invalid_del_stmt:
    | 'del' a=star_expressions {
        RAISE_SYNTAX_ERROR_INVALID_TARGET(DEL_TARGETS, a) }
invalid_block:
    | NEWLINE !INDENT { RAISE_INDENTATION_ERROR("expected an indented block") }
invalid_primary:
    | primary a='{' { RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "invalid syntax") }
invalid_comprehension:
    | ('[' | '(' | '{') a=starred_expression for_if_clauses
invalid_dict_comprehension:
    | '{' a='**' bitwise_or for_if_clauses '}'
invalid_parameters:
    | param_no_default* (slash_with_default | param_with_default+) param_no_default
invalid_lambda_parameters:
    | lambda_param_no_default* (lambda_slash_with_default | lambda_param_with_default+) lambda_param_no_default
invalid_star_etc:
    | '*' (')' | ',' (')' | '**'))
    | '*' ',' TYPE_COMMENT
invalid_lambda_star_etc:
    | '*' (':' | ',' (':' | '**'))
invalid_double_type_comments:
    | TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT
invalid_with_item:
    | expression 'as' a=expression

invalid_for_target:
    | 'for' a=star_expressions

invalid_group:
    | '(' a=starred_expression ')'
invalid_import_from_targets:
    | import_from_as_names ','
